# 그래프 이론

### 그래프(graph)
- 그래프:&nbsp; 노드(node)와 간선(edge)의 정보를 가지고 있는 자료 구조
- 서로 다른 개체(or 객체)가 연결되어 있다는 이야기를 들으면 가장 먼저 그래프 알고르즘을 떠올려야 한다.
- 구현 방법
  - 인접 행렬(adjacency matrix): 2차원 배열을 사용하는 방식
  - 인접 리스트(adjaceny list): 리스트를 사용하는 방식

<br/>

### 기타 알고리즘
- **서로소 집합(disjoint sets) 자료구조**
  - 서로소 집합:&nbsp; 공통 원소가 없는 두 집합&nbsp;(ex. {1,2}와 {3,4})
  - 서로소 집합 자료구조:&nbsp; 서로고 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조(union(합집합)과 find(찾기) 연산으로 조작)
  - 구현(트리 자료구조 이용)
    1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인\
      (1) A와 B의 루트노드 A', B'를 각각 찾는다.\
      (2) A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다).
    2. 모든 union(합집합) 연산을 처리할 때까지 1번 과정을 반복한다.
  - Example
    - 전체 집합 {1, 2, 3, 4, 5, 6}
    - 주어진 연산:&nbsp;&nbsp;union 1, 4 |&nbsp;&nbsp;union 2, 3 |&nbsp;&nbsp;union 2, 4 |&nbsp;&nbsp;union 5, 6
      - 연산의 의미: 1과 4는 같은 집합 / 작은 번호가 부모 노드로 생각
    - 6개의 노드와 4개의 간선이 존재하는 그래프
  - 시간 복잡도: \
    V개의 노드, 최대 V-1개의 union연산, M개의 find 연산이 가능한 경우 경로 압축 방법을 적용한 시간복잡도는\
    $O(V + M(1 + log_{2-M/V}V))$

  - 서로소 집합을 활용한 사이클 판별
    - 무방향 그래프 내에서 사이클을 판별할 때 사용 가능 (방향 그래프에서 사이클 여부는 DFS를 이용해 판별 가능)
    - 알고리즘 원리
      1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다. \
        (1). 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.\
        (2). 루트 노드가 서로 같다면 사이클(cycle)이 발생한 것이다.
      2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.
     
<br/>

- **신장 트리 (spanning tree)**
  - 신장 트리:&nbsp; 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
  - 일종의 트리 자료구조로 '간선의 개수 = 노드의 개수 - 1' 이라는 특징이 있다.
  - 활용 예시: N개의 도시가 존재하는 상황에서 모든 도시를 '연결'할 때, 최소한의 비용으로 연결하기 위한 비용
  - **크루스칼 알고리즘 (kruskal algorithm)**
    - 대표적인 최소 신장 트리 알고리즘
    - 사용 시 가장 적은 비용으로 모든 노드를 연결할 수 있으며, 그리디 알고리즘으로 분류
    - 알고리즘 원리
      - 먼저 모든 간선에 대하여 정렬을 수행한 뒤 가장 거리가 짧은 간선부터 집합에 포함
      - 이때 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다.
      1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
      2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다. \
        (1) 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다. \
        (2) 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
      3. 모든 간선에 대하여 2번의 과정을 반복한다.
    - 시간 복잡도: O(ElogE) , E: 간선의 개수
   
<br/>

- **위상 정렬 (topology sort)**
  - 위상 정렬
    - 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'
    - 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘
  - 활용 예시: 선수과목을 고려한 학습 순서 설정 (ex. 자료구조 강의 -> 알고리즘 강의 -> 고급 알고리즘 강의)
  - **진입차수 (indegree)**: 특정한 노드로 '들어오는' 간선의 개수
  - 알고리즘 원리
    1. 진입차수가 0인 노드를 큐에 넣는다.
    2. 큐가 빌 때까지 다음의 과정을 반복한다. \
        (1) 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다. \
        (2) 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.
  - 위 알고리즘에서 모든 원소를 방문하기 전 큐가 빈다면 사이클 발생을 의미\
    기본적으로 위상 정렬 문제에서는 사이클이 발생하지 않는다고 명시하기에 여기서는 사이클 발생을 고려하지 않음
  - 시간 복잡도: O(V + E)
