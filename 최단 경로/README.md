# 최단 경로

### 최단 경로(Shortest Path)
- 가장 짧은 경로를 찾는 알고리즘 (= 길 찾기 문제)
- 최단 경로 알고리즘 유형 예시
  - 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우
  - 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우
- 기본적인 최단 알고리즘
  - 다익스트라 최단 경로 알고리즘
  - 플로이드 워셜
  - 벨만 포드 알고리즘
- 최단 경로는 그리디 알고리즘 및 다이나믹 프로그래밍 알고리즘의 한 유형
 
<br/>

### 다익스트라(Dijkstra) 최단 경로 알고리즘
- 그래프에서 여러 개의 노드가 있는 경우, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
- 특징
  - "음의 간선"이 없을 때 정상적으로 동작 (음의 간선: 0보다 작은 값을 가지는 간선을 의미)
  - 현실 세계의 길은 음의 간선으로 표현되지 않으므로 GPS SW의 기본 알고리즘으로 채택됨
  - 기본적으로 그리디 알고리즘으로 분류 (매번 '가장 비용이 적은 노드'를 선택하는 임의의 과정을 반복)
  - 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리'정보를 항상 1차원 리스트에 저장하며 계속해서 갱신(= 최단 거리 테이블)
- 알고리즘 원리
  1. 출발 노드를 설정
  2. 최단 거리 테이블을 초기화
  3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
  5. 위 과정에서 3과 4를 반복 (더 짧은 경로를 찾으면 '더 짧은 경로도 있었네?' 이걸로 업데이트)
- 알고리즘 구현 방법
  1. 구현하기 쉽지만 느리게 동작하는 코드
  2. 구현하기에 조금 더 까다롭지만 빠르게 동작하는 코드

- **방법 1. 간단한 다익스트라 알고리즘**
  - 다익스트라에 의해 처음 고안된 알고리즘으로 시간 복잡도는 O(V^2), V: 노드의 개수
  - 이 알고리즘은 쉽게 이해할 수 있음
  - 처음에 각 노드에 대한 최단 거리를 담은 1차원 리스트를 선언
  - 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택'하기 위해 \
    매 단계마다 1차원 리스트의 모든 원소를 확인(순차 탐색)
  - 책에서는 최단 경로가 아닌 '최단 거리'만 다룸
  - 노드의 수가 10,000개를 넘어가는 문제는 이 코드로는 해결이 어려움

- **방법 2. 개선된 다딸익스트라 알고리즘**
  - 최악의 시간 복잡도 O(ElogV), V: 노드의 개수, E: 간선의 개수
  - 힙(Heap) 자료구조를 사용
    - 우선순위 큐(priority queue)를 구현하기 위해 사용하는 자료구조 중 하나
    - 우선순위 큐: 우선순위가 가장 높은 데이터를 가장 먼저 삭제
    - 최소 힙: 값이 낮은 데이터가 먼저 삭제 / 최대 힙: 값이 큰 데이터가 먼저 삭제
    - 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용
  - '최단 거리가 가장 짧은 노드'를 선택하는 과정을 다익스트라 최단 경로 함수안에서 우선순위 큐를 이용하는 방식으로 대체 가능하기에\
    간단한 방법의 get_smallest_node()함수가 불필요

<br/>

### 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm)
- "모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야하는 경우" 사용 가능한 알고리즘
- 특징
  - 다익스트라 알고리즘에 비해 구현 과정이 쉬움
  - 다익스트라 알고리즘과 같이 '거쳐 가는 노드'를 기준으로 알고리즘을 수행하지만, \
    매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 다름
  - 시간 복잡도: O(N^3), N: 노드의 개수
  - 2차원 리스트에 '최단 거리'정보를 저장
  - 다이나믹 프로그래밍으로 분류 (다익스트라 알고리즘은 그리디 알고리즘)
- 알고리즘 원리
  - 각 단계에서는 해당 노드를 거쳐가는 경우를 고려
  - 예를 들어 1번 노드에 대해서 확인 시 1번 노드를 중간에 거쳐 지나가는 모든 경우를 고려 (ex. A -> 1번 노드 -> B)
  - 따라서 알고리즘에서는 현재 확인하고 있는 노드를 제외하고, N-1개의 노드 중에서 서로 다른 노드 (A, B)쌍을 선택 후\
    A -> 1번노드 -> B로 가는 비용을 확인 후 (A -> B 비용보다 저렴한 경우) 최단 거리를 갱신
  - 다시 말해 $_{N-1}P_2$ 개의 쌍을 단계 마다 반복해서 확인
  - $D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$

